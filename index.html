<!DOCTYPE html>
<html>
<meta charset="utf-8">
<!-- 
Copyright 2014 Eliot Stock

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<style>
	body { font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 12px; text-align: center; }
	.chart { display: block; margin: auto; }
	rect { stroke: #EEEEEE; fill: #AAAAAA; fill-opacity: 0.8; }
	rect.parent { cursor: pointer; fill: steelblue; }
	text { pointer-events: none; }
</style>
<body>
<p>
	Select an ld *.map file: <input id="file" type="file"/>
</p>
<p id="error">&nbsp;</p>
</body>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js" type="text/javascript"></script>
<script src="http://d3js.org/d3.v3.min.js" type="text/javascript"></script>
<script>

var w = 1120,
    h = 680,
    x = d3.scale.linear().range([0, w]),
    y = d3.scale.linear().range([0, h]);
    
var reader = new FileReader();

var vis = d3.select("body").append("div")
	.attr("class", "chart")
	.style("width", w + "px")
	.style("height", h + "px")
	.append("svg:svg")
	.attr("width", w)
	.attr("height", h);

// TODO: Put high memory at the top of the screen, zero at the bottom.
var partition = d3.layout.partition()
	.value(function(d) { return d.size; })
	.sort(null); // Don't sort by size, just use the order in the child arrays.

var checkForHtml5FileApis = function() {
	if (window.File && window.FileReader) {
		console.log("HTML5 File APIs supported.");
	}
	else {
		$("p#error").html("HTML5 File APIs NOT supported. Can't continue. Please use a modern,"
				+ " desktop web browser.");
		$("p#error").show();
	}
};
    
$("#file").change(function(e) {
	var files = e.target.files;
	
	if (files.length != 1) {
		return error("Please select one and only one file.");
	}
	
    // We could throw an error here if files[0].type !== "text/plain", but it would
    // only be any good on Mac. Windows doesn't get a file type at all.
	
	// Calls back to reader.onload() below.
	console.log("Reading file: " + files[0].name);
	reader.readAsText(files[0]);
});

reader.onload = function(e) {
	var inputFile = e.target.result;
	
	// Windows:							CRLF    \r\n
	// Unix, inc. Mac OS:				LF      \n
	// Excel for Mac "Save As CSV":		CR		\r
	var lines = inputFile.split(/\r\n?|\n/); // Any of the above
	
	var root = {"name": "Memory", "children": []};
	var memoryTop = 0;
	
	var lineNumberToStartMemoryParsingFrom = parseMemoryConfig(lines, root);
	
	// Blocks are not necessarily in order. Sort them by origin.
	root.children.sort(sortByOrigin);
		
	fillInBlankSpace(root);
	
	// console.log("Memory blocks:");
	// console.log(root.children);
	
	parseMemory(lines, root, lineNumberToStartMemoryParsingFrom);
	
	// The root node needs an origin and an end as well
	root.origin = root.children[0].origin;
	root.end = root.children[root.children.length - 1].end;
	
	// Reverse the order of all nodes so that we're drawing 0x0 at the top of the screen.
	reverseChildren(root);
	
	console.log("root:");
	console.log(root);
	
	// Don't let any node at the block level get smaller than what we can click on.
	// Probably not a good idea.
	// enlargeTinyBlocks(root);
	
	display(root);
    
    // Blank out the file chooser field. If we don't do this, choosing the same file again
    // after editing doesn't change the value and the change() handler is never called.
    $("#file").val("");
};

var parseMemoryConfig = function(lines, root) {
	var inMemoryConfig = false;
	var lineNumber = 0;
	
	for (var l = 0; l < lines.length; l++) {
		var line = lines[l];
		lineNumber++;
		
		// Memory configuration looks like this:
		// Name             Origin             Length             Attributes
		// FLASH            0x0000000000016000 0x000000000002a000 xr
		// RAM              0x0000000020002000 0x0000000000002000 xrw
		// *default*        0x0000000000000000 0xffffffffffffffff
		if (line.indexOf("Name") != -1
				&& line.indexOf("Origin") != -1
				&& line.indexOf("Length") != -1) {
			// Memory configuration starts on the next line
			inMemoryConfig = true;
			continue;
		}
		
		// Split line into cells based on any whitespace.
		var cells = line.trim().split(/\s+/);
		
		if (inMemoryConfig) {
			// We know we're done with the memory configuration section when we see a blank line.
			if (cells.length == 1 && cells[0] == "") {
				// Return the line number we're on now so that the next function can pick up from here.
				return lineNumber;
			}
			
			var name = cells[0];
			var origin = parseInt(removeLeading0x(cells[1]), 16);
			var declaredSize = parseInt(removeLeading0x(cells[2]), 16);
			var end = origin + declaredSize;
			
			// Ignore a line like:
			// *default*        0x0000000000000000 0xffffffffffffffff
			if (name == "*default*") {
				continue;
			}
			
			// A block's declared size is not just the sum of its children - it can have space left
			// over. D3 will set the size of a node to the sum of it's children, but there's no
			// child for free space left over. We create one later.
			var block = {"name": name, "declaredSize": declaredSize, "origin": origin, "end": end,
					"children": []};
			root.children.push(block);
		}
	}	
};

var fillInBlankSpace = function(root) {
	// Let d3 calculate the size of each node based on the sum of its children.
	var nodes = partition.nodes(root);
	
	// Figure out where the top of our memory is.
	memoryTop = 0;
	
	for (var i = 0; i < root.children.length; i++) {
		var block = root.children[i];
		
		if (block.end > memoryTop) {
			memoryTop = block.end;
		}
	}
	
	console.log("Top of memory: " + toHex(memoryTop));
	
	// Figure out the average size of a declared memory block.
	var averageBlockSize = 0;
	var totalBlockMemory = 0;
	
	for (var i = 0; i < root.children.length; i++) {
		var block = root.children[i];
		
		if (typeof(block.declaredSize) == "undefined") {
			continue;
		}
		
		totalBlockMemory += block.declaredSize;
	}
	
	averageBlockSize = totalBlockMemory / root.children.length;
	
	console.log("Average declared block size: " + toHex(averageBlockSize));
	
	// If the first block doesn't start at zero, put some free space in before it. Because free
	// space can be thousands of times larger than the blocks it surrounds, don't draw this to
	// scale. Just make it about the same size as everything else.
	if (typeof root.children !== 'undefined' && root.children.length > 0) {
		var firstBlock = root.children[0];
		
		if (firstBlock.origin != 0) {
			var initialFreeSpace = {"name": "FREE",
					"children": [],
					"origin": 0,
					"size": averageBlockSize,
					"sizeForLabel": firstBlock.origin,
					"end": firstBlock.origin - 1};
			
			console.log("Adding free space before first declared block: " + toHex(firstBlock.origin));
			// console.log(initialFreeSpace);
			
			root.children.push(initialFreeSpace);
			root.children.sort(sortByOrigin);
			nodes = partition.nodes(root);
		}
	}
	
	// Fill in the blank space between blocks. Because free space can be thousands of times larger
	// than the blocks it surrounds, don't draw this to scale. Just make it about the same size as
	// everything else.
	for (var i = 0; i < root.children.length; i++) {
		var thisBlock = root.children[i];
		var nextBlock = root.children[i + 1];
		
		if (typeof nextBlock == "undefined") {
			// End of blocks. Done.
			break;
		}
		
		var spaceBetween = nextBlock.origin - thisBlock.end;
		
		if (spaceBetween > 1) {
			var freeSpace = {"name": "FREE",
					"children": [],
					"origin": thisBlock.end,
					"size": averageBlockSize,
					"sizeForLabel": spaceBetween,
					"end": thisBlock.end + spaceBetween};
			
			console.log("Block " + thisBlock.name + " ends at " + toHex(thisBlock.end)
					+ " and the next one, " + nextBlock.name + ", starts at "
					+ toHex(nextBlock.origin) + ". Adding free space between blocks: "
					+ toHex(spaceBetween));
			// console.log(freeSpace);
			
			root.children.push(freeSpace);
			root.children.sort(sortByOrigin);
			nodes = partition.nodes(root);
		}		
	}
	
	// Create nodes for left over free space inside each block. This is to scale.
	for (var i = 0; i < root.children.length; i++) {
		var block = root.children[i];
		
		if (block.value < block.declaredSize) {
			var freeSpace = {"name": "FREE",
					"children": [],
					"size": (block.declaredSize - block.value)};
			
			if (typeof block.children == "undefined") {
				block.children = [];
			}
			
			block.children.push(freeSpace);
		}
	}
	
	// Let d3 process the nodes again now that the free space is there.
	nodes = partition.nodes(root);
};

var parseMemory = function(lines, root, lineNumberToStartMemoryParsingFrom) {
	var chunkCount = 0;
	
	for (var l = lineNumberToStartMemoryParsingFrom; l < lines.length; l++) {
		var line = lines[l];
		
		// Split line into cells based on any whitespace.
		var cells = line.trim().split(/\s+/);

		// We're done once we reach the end of the stack. Ignore debug symbols and so on.
		if (line.indexOf("OUTPUT") == 0) {
			break;
		}
		
		// Ignore lines that aren't for a source file. Later we may want to go down to the symbol
		// lines below that.
		if (!isSourceLine(cells)) {
			continue;
		}
		
		// Memory section, eg. .text, .data., .bss.
		var sectionName = cells[0];
		
		// Start address in memory, eg. 0x000000002000210c, as integer.
		var startAddress = parseInt(removeLeading0x(cells[1]), 16);
		
		// Size of this chunk of memory, eg. 0x1f4, as integer.
		var size = parseInt(removeLeading0x(cells[2]), 16);
		
		// C or assembler source file for this chunk of memory.
		var sourceFile = filenameFromPath(cells[3]);
		
		// Ignore anything with size zero.
		if (size == 0) {
			continue;
		}
		
		// Find the first block of memory that this start address falls within.
		var block = null;
		
		for (var i = 0; i < root.children.length; i++) {
			var b = root.children[i];
			
			if (startAddress >= b.origin && startAddress < b.end) {
				block = b;
				
				// console.log("Chunk " + sectionName + " with start address " + startAddress
				//		+ " is within block:");
				// console.log(block);
				
				break;
			}
		}
		
		if (block == null) {
			console.log("Can't find which block of memory" + cells[1] + " is in. Ignoring "
					+ sourceFile);
			continue;
		}
		
		// Seems that d3 removes the children array when it's empty.
		if (typeof(block.children) == "undefined") {
			block.children = [];
		}

		// Find the memory section within the block, or create it if this is the first time we've
		// seen it.
		var section = block.children.filter(function(child) {
			return child.name == sectionName;
		})[0];
		
		if (section == null) {
			section = {"name": sectionName, "children": []};
			block.children.push(section);
		}
		
		var chunk = {"name": sourceFile, "size": size};
		// console.log(chunk);
		
		if (section.children.length > 0) {
			var last_chunk = section.children[section.children.length - 1];
			
			if (last_chunk.name == chunk.name) {
				last_chunk.size += chunk.size;
			}
			else {
				section.children.push(chunk);
				chunkCount++;
			}
		}
		else {
			section.children.push(chunk);
			chunkCount++;
		}
	}
	
	console.log("Found " + chunkCount + " chunks of memory.");
};

var reverseChildren = function(node) {
	if (!node || !node.children || node.children.length <= 1) return;
	
	node.children.reverse();
	
	for (var i = 0; i < node.children.length; i++) {
		var child = node.children[i];
		reverseChildren(child);
	}
};

var enlargeTinyBlocks = function(root) {
	var minimumBlockValue = Math.round(memoryTop / 100000);
	
	for (var i = 0; i < root.children.length; i++) {
		var block = root.children[i];
		
		// By now, every block either has a size, calculated by d3, or a declared size from
		// the .Map file.
		var effectiveSize = block.size ? block.size : block.declaredSize;
		
		if (effectiveSize < minimumBlockValue) {
			console.log("Enlarging tiny block " + block.name + " from " + toHex(effectiveSize)
					+ " to " + toHex(minimumBlockValue) + ".");
			
			block.size = minimumBlockValue;
		}
	}
	
	nodes = partition.nodes(root);
};

var display = function(root) {
	nodes = partition.nodes(root);
	
	var g = vis.selectAll("g")
		.data(nodes)
		.enter().append("svg:g")
		.attr("transform", function(d) { return "translate(" + x(d.y) + "," + y(d.x) + ")"; })
		.on("click", click);

	var kx = w / root.dx,
		ky = h / 1;
	
	var nodeLabel = function(d) {
		if (d.sizeForLabel) {
			return d.name + ": " + toHex(d.sizeForLabel) + " (not to scale)";
		}
		else {
			return d.name + ": " + toHex(d.value);
		}
	};

	g.append("svg:rect")
		.attr("width", root.dy * kx)
		.attr("height", function(d) { return d.dx * ky; })
		.attr("class", function(d) { return d.children ? "parent" : "child"; });

	// End
	g.append("svg:text")
		.attr("transform", function(d) { return "translate(4,10)"; })
		.attr("dy", ".35em")
		.style("opacity", function(d) { return d.dx * ky > 12 ? 1 : 0; })
		.style("font-size", "1em")
		.text(function(d) { return toHex(d.end); });
	
	// Label
	g.append("svg:text")
		.attr("transform", function(d) { return "translate(16," + d.dx * ky / 2 + ")"; })
		.attr("dy", ".35em")
		.style("opacity", function(d) { return d.dx * ky > 12 ? 1 : 0; })
		.style("font-size", "1em")
		.text(nodeLabel);
	
	// Origin
	g.append("svg:text")
		.attr("transform", function(d) { return "translate(4," + ((d.dx * ky) - 10) + ")"; })
		.attr("dy", ".35em")
		.style("opacity", function(d) { return d.dx * ky > 12 ? 1 : 0; })
		.style("font-size", "1em")
		.text(function(d) { return toHex(d.origin); });

	d3.select(window)
		.on("click", function() { click(root); });

	// On clicking a node, redo the layout with that node as the root.
	function click(d) {
		if (!d.children) return;

		kx = (d.y ? w - 40 : w) / (1 - d.y);
		ky = h / d.dx;
		x.domain([d.y, 1]).range([d.y ? 40 : 0, w]);
		y.domain([d.x, d.x + d.dx]);

		var t = g.transition()
			.duration(d3.event.altKey ? 7500 : 750)
			.attr("transform", function(d) { return "translate(" + x(d.y) + "," + y(d.x) + ")"; });

		t.select("rect")
			.attr("width", d.dy * kx)
			.attr("height", function(d) { return d.dx * ky; });

		// TODO: Scale end, label and origin
		// t.select("text")
		// 	.attr("transform", function(d) { return "translate(12," + d.dx * ky / 2 + ")"; })
		// 	.style("opacity", function(d) { return d.dx * ky > 12 ? 1 : 0; });

		d3.event.stopPropagation();
	}
};

var isSourceLine = function(cells) {
	if (cells == null) return false;
	
	if (cells.length === undefined) return false;
	
	if (cells.length != 4) return false;
	
	// Second cell must start with 0x
	if (cells[1].indexOf("0x") != 0) return false;
	
	// Third cell must also start with 0x
	if (cells[2].indexOf("0x") != 0) return false;
	
	return true;
};

var removeLeading0x = function(value) {
	if (!value) return value;
	
	if (value.indexOf("0x") != 0) {
		return value;
	}
	
	return value.substring(2, value.length);
};

var toHex = function(value) {
	if (!value) return value;
	
	if (isNaN(value)) return value;
	
	return "0x" + value.toString(16).toUpperCase();
};

var sortByOrigin = function(a, b) {
	if (!a || !b) return 0;
	
	if (typeof a.origin == "undefined" || typeof b.origin == "undefined") return 0;
	
	if (a.origin == b.origin) {
		return 0;
	}
	else if (a.origin > b.origin) {
		return 1;
	}
	else {
		return -1;
	}
};

var filenameFromPath = function(value) {
	var lastSlash = value.lastIndexOf("/");
	return value.substring(lastSlash + 1, value.length);
};

$(document).ready(function() {
	checkForHtml5FileApis();
});
</script>
</html>
